# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?

In Console.rb when Property.new is 'newed up', but also in property.rb in the .all, .find. and
.find_by_address methods which use Property.new to return a hash.

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?

In the .save method, with the sql = "" command specifically, where SQL commands can be written
between the quotes.  

Q3. In `console.rb`, which lines modify the database?

4 with a .delete_all, 13 22 and 31 with a .save, and 33 with a .delete.

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?

Because we want the id to be created when it is actually saved to the database, and it may
be saved multiple times, so would generate a different id each time it is saved. If
we did it at the moment of instantiation, then it would be fixed in a way that is not useful
as an id.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?

Because it is generated by the database itself it originates in the SQL file itself and is set
up when the database is first run with the psql -d database_name -f file_name setup process

The exact line that does it would be:

`id SERIAL PRIMARY KEY`

This begins a PK count that increments with each new addition to the database, and this
id can then be used as a unique identifier and stored in an `@id`

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?

So that on the first run through the code, it doesn't generate an error because it checks
if it exists first.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Because some operations, like single_delete, operate only once, whereas some, like
.all operate on the whole class and thus require access to all of it.  

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

An array is returned from db.exec_prepared.  

In the save method, the `@id = db.exec_prepared("save", values)[0]["id"].to_i` line
is used to reduce the full array output to an integer, by first taking the first element,
[0], then the key value "id", then converting it to an integer with .to_i.s

Q9. Why do we use prepared statements when performing database operations?

To defend against a SQL injection attack by sanitising the input and using place-holders like
$1 $2 $3 etc.   

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

id for find_by_id and address for find_by_address

Q11. What are their return values?

The full property object, with the id or address that was searched for.  
